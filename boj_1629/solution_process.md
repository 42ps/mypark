### 문제 소개
[boj_1629](https://www.acmicpc.net/problem/1629)

### 입/출력 분석
- 모든 입/출력 경우의 수를 나열하시오.

A B C

1 <= A,B,C <= 2 ^ 32 - 1

### 풀이
- 풀이 과정 (풀이의 논리가 담긴 글)
```
A % C = R1
A^2 % C = R2 
...
A^k % C = Rk
```
일 때, 수열 R이 순환함을 증명하자.

A^(m+n) = A^m = R0 (mod x)를 만족하는 n이 존재한다면,
```
A^(m+1) = A * R0 (mod x)
A^(m+2) = A^2 * R0 (mod x)
...
A^(m+n) = A^n * R0 = A^m = R0 (mod x)
```
이므로 수열 R이 순환함을 보일 수 있다.

x보다 큰 자연수 y에 대해,
```
A^m = R0 (mod x)
A^(m+1) = A * R0 = R1 (mod x)
A^(m+2) = A^2 * R0 = R2 (mod x)
...
A^(m+y) = A^y * R0 = Ry (mod x)

R` = [R1, R2, ... , Ry]
```
수열 R`안에 R0와 같은 어떤 원소는 항상 존재하므로(나머지 연산의 결과값은 가짓수가 (나누는 수 -1) 이다) <= 여기 틀림.

수열 R`안의 서로 같은 어떤 두 원소는 항상 존재하므로(나머지 연산의 결과값은 가짓수가 (나누는 수 -1) 이다)

어떤 자연수 m에 대해 A^m보다 큰 A의 거듭제곱수를 x로 나눈 나머지는 순환한다.

어떤 자연수 m은 어떻게 구하나?


- 풀이의 중심이 되는 알고리즘이 무엇인가?
수학(정수론)

- 왜 이 알고리즘을 선택했는가?
무식하게 곱셈을 하기에는 결과값이 너무 커서.

- 시간복잡도를 계산하시오.

- 공간복잡도를 계산하시오.

- special case가 있는가?

### 슈도 코드 작성
```
remains = [false ; C];
seq = Vec::new();

i = 1;
r = pow(A, i) % C;

while !remains[r] {
	remains[r] = true;
	seq.push(r);
	i += 1;

	r = pow(A, i) % C
}

```
### 소스 코드 작성
제출 파일.

### 테스트 작성
