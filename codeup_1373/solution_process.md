### 문제 소개
[codeup_1373](https://codeup.kr/problem.php?id=1373)

### 입/출력 분석
- 모든 입/출력 경우의 수를 나열하시오.

n m k p

| n, m | <= 1200, 0 <= p <= 6,000,000, 0 <= k <= 1

(n, m) = (0, 0), (0, 1), (1, 0), (1, 1), (0, 2), (2, 0), (1, 2), (2, 1), (2, 2) ...

### 풀이
- 풀이 과정 (풀이의 논리가 담긴 글)

n >= 2, m >= 2일 때,
```

0
...
1
1
1 xy
0 1 1 1 1 ... 0

for x,y in (1..n) x (1..m):
	[x][y] = [x-1][y] + [x][y-1]

if p == 0 {
	p = 1;
}

if k == 1 {
	if n == m {
		result = [n][m] - 2
	} else if n + 1 == m || m + 1 == n {
		result = [n][m] - 1
	}
} else {
	result = [m][m]
}

result %= p
```

- 풀이의 중심이 되는 알고리즘이 무엇인가?
DP

- 왜 이 알고리즘을 선택했는가?
현재 점까지의 경로를 계산할 때, 왼쪽에서 오는 경우와 아래쪽에서 오는 경우 둘을 합한 경우가 최단 경로이므로.

- 시간복잡도를 계산하시오. O(N M)

- 공간복잡도를 계산하시오. O(N M)

- special case가 있는가?

(n, m) = (0, 0), (0, 1), (1, 0), (1, 1), (1, 2), (2, 1)

(n, m, k)
```
(0, 0, 0) -> (4, 8),
(0, 0, 1) -> (6, 24),

(0, 1, 0), (1, 0, 0) -> (3, 2),
(0, 1, 1), (1, 0, 1) -> (5, 10),

(1, 1, 0) -> (4, 4),
(1, 1, 1) -> (4, 4),

(0, 2, 0), (2, 0, 0) -> (3, 2),
(0, 2, 1), (2, 0, 1) -> (5, 10),
```

### 슈도 코드 작성

### 소스 코드 작성
제출 파일.

### 테스트 작성
