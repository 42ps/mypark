### 문제 소개
ex) [상근이의 여행](https://www.acmicpc.net/problem/9372)

### 입/출력 분석
- 모든 입/출력 경우의 수를 나열하시오.

N(2 ≤ N ≤ 1 000), M(1 ≤ M ≤ 10 000)
1 ≤ a, b ≤ n; a ≠ b

A1 B1
A2 B2
...
Am Bm

### 풀이
- 풀이 과정 (풀이의 논리가 담긴 글)
주어진 입력으로 인접리스트를 만든다.

bfs알고리즘으로 각 노드를 방문하며 사용한 edge의 갯수를 센다.

- 풀이의 중심이 되는 알고리즘이 무엇인가?
bfs알고리즘

- 왜 이 알고리즘을 선택했는가?

- 시간복잡도를 계산하시오.
O(N)

- 공간복잡도를 계산하시오.
O(N^2)

- special case가 있는가?
없음.

### 슈도 코드 작성

cin >> n >> m;
nearby: 인접리스트

q.push(0)
while (!q.empty()) {
	node = q.pop();

	if (visited[node])
		continue;
	
	visited[node] = true;
	plane_count++;
	
	for (to: nearby[node]) {
		if (!visited[to]) {
			q.push(to)
		}
	}
}

return plane_count;


### 소스 코드 작성
제출 파일.

### 테스트 작성
제출 파일.
