### 문제 소개
[이항_계수](https://www.acmicpc.net/problem/11401)

### 입/출력 분석
- 모든 입/출력 경우의 수를 나열하시오.

1 ≤ N ≤ 4,000,000, 0 ≤ K ≤ N

### 풀이
- 풀이 과정 (풀이의 논리가 담긴 글)
nCr을 구하고, 1,000,000,007로 나눈 나머지를 구하는 문제이다.

1. nCr = n! / ( r! * (n-r)! )인데, n이 너무 커서 n!을 자료형에 담아서 계산할 수 없었다.
2. nCr = n-1Cr-1 + n-1Cr 공식을 이용한 DP풀이로 가능한 지 계산해보았을 때, 1억번이 충분히 넘는 연산횟수가 필요했다.

검색을 통해 페르마의 소정리를 이용한 풀이가 있는 것을 알 수 있었고, 페르마 소정리와 함께 정수론 합동식 기초를 공부했다.

- mul_mod(range, mod): range 값을 순회하며 나머지 연산 후 곱함.
- pow_mod(base, pow, mod): base^pow 연산을 분할 정복을 적용해 구하고, 중간중간에 나머지 연산을 통해 산술 오버플로를 방지.

```
x = max(r, n - r);
y = min(r, n - r);
m = 1_000_000_007;
numerator = mul_mod(x+1..=n);
denominator = mul_mod(1..=y);
inv_deno = denominator ^ -1; // 곱셈 역원

nCr % m = ( numerator * inv_deno ) % m
```

numerator와 denominator는 합동식의 원리를 이용해서 구한 것이므로, 나눗셈 연산을 할 때, 합동식의 곱셈 역원(inv_deno)을 구해서 곱해주어야 함.
그 과정에서 페르마의 소정리를 적용한다.

```
어떤 정수 a가 어떤 소수 p의 약수가 아닐 때,
a ^ p = a (mod p)
a ^ (p - 1) = 1 (mod p) // 합동식의 곱셈역원 존재? -> 베주 항등식 활용.
a ^ (p - 2) = a ^ -1 (mod p)

inv_deno = denominator ^ -1 = denominator ^ (p - 2) // 분할정복 거듭제곱 알고리즘 활용.
= pow_mod(denominator, m - 2, m);
```

- 풀이의 중심이 되는 알고리즘이 무엇인가?
정수론 합동식.
페르마의 소정리.
분할정복 거듭제곱수.

- 왜 이 알고리즘을 선택했는가?
DP로 풀기엔 N이 너무 커서 계산 횟수가 너무 많음.

- 시간복잡도를 계산하시오. O(N)

- 공간복잡도를 계산하시오. O(1)

- special case가 있는가?

### 슈도 코드 작성
공책에 적었다.

### 소스 코드 작성
제출 파일.

### 테스트 작성

### 증명
```
// 모듈러 연산 분배법칙 증명.
(a*b) % m == (a%m) * (b%m) ?

a = Am + R1
b = Bm + R2

a*b = AB m^2 + R1 Bm + R2 Am + R1 R2
(a*b) % m = R1 R1

a%m = R1
b%m = R2
(a%m) * (b%m) = R1 R2

-> (a*b) % m == (a%m) * (b%m)
```
