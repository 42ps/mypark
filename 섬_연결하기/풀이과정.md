### 문제 소개
ex) [섬 연결하기](https://school.programmers.co.kr/learn/courses/30/lessons/42861?language=cpp)

### 입/출력 분석
- 모든 입/출력 경우의 수를 나열하시오.

1 <= n <= 100, costs.size <= n(n-1) / 2

costs = [
	[x, y, c]
	...
]

ex) n = 1, costs = []

ex) n = 2,

costs = [
	[0, 1, c]
]

ex) n = 3,

costs = [
	[0, 1, c0],
	[1, 2, c1],
]

costs = [
	[0, 1, c0],
	[0, 2, c1],
]

costs = [
	[0, 1, c0],
	[0, 2, c1],
	[1, 2, c2]
]

...

### 풀이
- 풀이 과정 (풀이의 논리가 담긴 글)
프림 알고리즘을 이용하여 mst를 만드는 과정에서 정답을 구한다.

- 풀이의 중심이 되는 알고리즘이 무엇인가?
프림

- 왜 이 알고리즘을 선택했는가?
MST를 구하는 문제여서

- 시간복잡도를 계산하시오. O((n + costs.size)log(n))..?

- 공간복잡도를 계산하시오. O(n^2)

- special case가 있는가?

### 슈도 코드 작성

nearby = costs -> 인접리스트
in_mst = [false; n]

pq.push({0, 0});

while (!pq.empty()) {
	cost, node = pq.top();
	pq.pop();

	if (in_mst[node]) {
		continue
	}

	in_mst = true;
	total_cost += cost;

	for(c, n : nearby[node]) {
		if (!in_mst[n] && c < least[n]) {
			least[n] = c;
			pq.push({c, n});
		}
	}
}


### 소스 코드 작성
ex) 제출 파일.

### 테스트 작성
ex) 프로그래머스 '테스트 추가하기' 사용.
